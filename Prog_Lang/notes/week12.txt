Type Conversion
    -converting from one type to another
        *can be built into the type system to happen automatically
    -implicit Conversion (coercion)  
        *inserted by the translator
    -widening Conversion
        *target data type can hold all of the converted data without loss of data
    -narrowing conversion 
        *conversion may involve a loss of data
    -C++ examples   
            double max (int, double);
            double max (double, int);
            max (2, 3);

            *ambiguous because of the possible implicit conversions from int to double on either first or second parameter
    -java only permits widening implicit conversions for arithmetic types
    -C++ emits warnings for narrowing
    -explicit casts need to be somewhat restricted 
        *often to simple types, or just arithmetic types
    -if casts are permitted for structured types, they must have identical sizes in memory
        *allows stanslation to reinterpret the memory as a different type
    -in C, malloc and free functions are declared using a generic pointer or anonymous pointer type void*
    -object oriented languages allow conversions from subtypes to supertypes and back in some cases

Polymorphic Type Checking


Chapter 9 - Control 1: Expressions and
-----------------------------------------
Expressions
    -basic expressions consist of literals 
    -sequence operator
        *allows several expressions to be combined into a single expression and evaluated sequentially
            ex in C: x = 
    -if (or if-then-else) operator is a ternary operator with three operands
    -mix form   
        *distributes parts of the syntax of the operator throughout the expression
    -if-expressions never have all of their subexpressions evaluated
    -case expression
        *similar to a series of nested-if expressions
    -delayed evaluation (or nonstrict evaluation)
        *when operators delay evaluating their operands 
    -substitution rule (or referentual transparency)
        *any two expressions that have the same value in the same scope may be substituted for each other 
            >their vales always remain equal regardless of the evaluation context 
            >note that this prohibits variables in the expressions
    -normal order evaluation
        *each operation begins its evaluation before its operands are evaluated, and each operand is evaluated only if it is needed for the calculation of the operation
    